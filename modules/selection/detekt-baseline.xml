<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>ComplexMethod:VaultWatcherService.kt$VaultWatcherServiceImpl$override fun selectTokens( owner: Holder, requiredAmount: Amount&lt;TokenType&gt;, predicate: ((StateAndRef&lt;FungibleToken&gt;) -&gt; Boolean), allowShortfall: Boolean, autoUnlockDelay: Duration, selectionId: String ): List&lt;StateAndRef&lt;FungibleToken&gt;&gt;</ID>
    <ID>ForbiddenComment:DatabaseTokenSelection.kt$DatabaseTokenSelection$// TODO: Need to specify exactly why it fails. Locked states or literally _no_ states!</ID>
    <ID>ForbiddenComment:DatabaseTokenSelection.kt$DatabaseTokenSelection$// TODO: revisit the back off strategy for contended spending.</ID>
    <ID>ForbiddenComment:Selector.kt$Selector$// TODO: This assumes there is only ever ONE notary. In the future we need to deal with notary change.</ID>
    <ID>LongMethod:VaultWatcherService.kt$VaultWatcherServiceImpl$override fun selectTokens( owner: Holder, requiredAmount: Amount&lt;TokenType&gt;, predicate: ((StateAndRef&lt;FungibleToken&gt;) -&gt; Boolean), allowShortfall: Boolean, autoUnlockDelay: Duration, selectionId: String ): List&lt;StateAndRef&lt;FungibleToken&gt;&gt;</ID>
    <ID>LongParameterList:DatabaseTokenSelection.kt$DatabaseTokenSelection$( private val persistenceService: PersistenceService, private val identityService: IdentityService, private val flowEngine: FlowEngine, private val maxRetries: Int, private val retrySleep: Int, private val retryCap: Int, private val pageSize: Int )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, externalId: UUID, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, lockId: UUID )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, externalId: UUID, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, queryBy: TokenQueryBy, lockId: UUID )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, holder: Holder, lockId: UUID, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, holder: Holder, lockId: UUID, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, queryBy: TokenQueryBy )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, holdingKey: PublicKey, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, lockId: UUID )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, holdingKey: PublicKey, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, queryBy: TokenQueryBy, lockId: UUID )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, lockId: UUID )</ID>
    <ID>LongParameterList:Selector.kt$Selector$( identityService: IdentityService, hashingService: HashingService, memberInfo: MemberInfo, partiesAndAmounts: List&lt;Pair&lt;AbstractParty, Amount&lt;TokenType&gt;&gt;&gt;, changeHolder: AbstractParty, queryBy: TokenQueryBy, lockId: UUID )</ID>
    <ID>LongParameterList:VaultWatcherService.kt$VaultWatcherService$( owner: Holder, requiredAmount: Amount&lt;TokenType&gt;, predicate: ((StateAndRef&lt;FungibleToken&gt;) -&gt; Boolean) = { true }, allowShortfall: Boolean = false, autoUnlockDelay: Duration = Duration.ofMinutes(5), selectionId: String )</ID>
    <ID>MagicNumber:LocalTokenSelector.kt$LocalTokenSelector$5</ID>
    <ID>MagicNumber:VaultWatcherService.kt$VaultWatcherService$5</ID>
    <ID>MagicNumber:VaultWatcherService.kt$VaultWatcherServiceImpl$1000</ID>
    <ID>MatchingDeclarationName:ExternalIdIndexUtils.kt$Holder</ID>
    <ID>MaxLineLength:DatabaseSelectionConfig.kt$DatabaseSelectionConfig$return DatabaseTokenSelection(persistenceService, identityService, flowEngine, maxRetries, retrySleep, retryCap, pageSize)</ID>
    <ID>MaxLineLength:DatabaseSelectionConfig.kt$DatabaseSelectionConfig.Companion$ConfigSelection.logger.info("Found database token selection configuration with values maxRetries: $maxRetries, retrySleep: $retrySleep, retryCap: $retryCap, pageSize: $pageSize")</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$)</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$*</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$// TODO After looking at VaultQueryCriteria implemenation of querying by external id we don't really support querying for keys not mapped to external id!</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$// This is due to the fact, that user can pass Amount&lt;IssuedTokenType&gt;, this usually shouldn't happen, but just in case</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$// We want the AbstractParty that this key refers to, unfortunately, partyFromKey returns always well known party</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$logger.trace("TokenType selection for $requiredAmount retrieved ${stateAndRefs.count()} states totalling $claimedAmount: $stateAndRefs")</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$logger.trace("TokenType selection requested $requiredAmount but retrieved $claimedAmount with state refs: ${stateAndRefs.map { it.ref }}")</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$private</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$throw InsufficientBalanceException("Insufficient spendable states identified for $requiredAmount.")</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$throw InsufficientNotLockedBalanceException("Insufficient not locked spendable states identified for $requiredAmount.")</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$val durationMillis = (minOf(retrySleep.shl(retryCount), retryCap / 2) * (1.0 + Math.random())).toInt()</ID>
    <ID>MaxLineLength:DatabaseTokenSelection.kt$DatabaseTokenSelection$val holderParty = if (knownParty.owningKey == holder.owningKey) knownParty else identityService.anonymousPartyFromKey(holder.owningKey)</ID>
    <ID>MaxLineLength:ExternalIdIndexUtils.kt$*</ID>
    <ID>MaxLineLength:ExternalIdIndexUtils.kt$fun</ID>
    <ID>MaxLineLength:ExternalIdIndexUtils.kt$return</ID>
    <ID>MaxLineLength:InMemorySelectionConfig.kt$InMemorySelectionConfig$throw IllegalArgumentException("Couldn't find VaultWatcherService in CordaServices, please make sure that it was installed in node.")</ID>
    <ID>MaxLineLength:InMemorySelectionConfig.kt$InMemorySelectionConfig.Companion$(config.get("stateSelection.inMemory.indexingStrategies") as List&lt;*&gt;).map { VaultWatcherService.IndexingType.valueOf(it.toString()) }</ID>
    <ID>MaxLineLength:InMemorySelectionConfig.kt$InMemorySelectionConfig.Companion$logger.info("Found in memory token selection configuration with values indexing strategy: $indexingType, cacheSize: $cacheSize")</ID>
    <ID>MaxLineLength:InMemorySelectionConfig.kt$InMemorySelectionConfig.Companion$logger.warn("Did not detect a configuration for InMemory selection - enabling memory usage for token indexing. Please set stateSelection.inMemory.enabled to \"false\" to disable this")</ID>
    <ID>MaxLineLength:InMemorySelectionConfig.kt$InMemorySelectionConfig.Companion$logger.warn("No indexing method specified. Indexes will be created at run-time for each invocation of selectTokens")</ID>
    <ID>MaxLineLength:LocalTokenSelector.kt$LocalTokenSelector$*</ID>
    <ID>MaxLineLength:SelectionUtilities.kt$fun</ID>
    <ID>MaxLineLength:Selector.kt$Selector$"States selected have different notaries. For now we don't support notary change, it should be performed beforehand."</ID>
    <ID>MaxLineLength:Selector.kt$Selector$*</ID>
    <ID>MaxLineLength:Selector.kt$Selector$return generateMove(identityService, hashingService, memberInfo, holder, lockId, partiesAndAmounts, changeHolder, TokenQueryBy())</ID>
    <ID>MaxLineLength:Selector.kt$Selector$return generateMove(identityService, hashingService, memberInfo, partiesAndAmounts, changeHolder, TokenQueryBy(), lockId)</ID>
    <ID>MaxLineLength:StateSelectionConfig.kt$ConfigSelection$*</ID>
    <ID>MaxLineLength:StateSelectionConfig.kt$ConfigSelection$else -&gt; throw IllegalArgumentException("Provide correct state-selection type string in the config, see kdocs for ConfigSelection.")</ID>
    <ID>MaxLineLength:TokenQueryBy.kt$TokenQueryBy$constructor(predicate: (StateAndRef&lt;FungibleToken&gt;) -&gt; Boolean, customPostProcessorName: String?) : this(null, predicate, customPostProcessorName)</ID>
    <ID>MaxLineLength:VaultMigratorService.kt$VaultMigratorServiceImpl$//TODO - we should attempt to migrate the old vault contents. This must be done a service because we cannot guarantee</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$TokenBucket$class</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$// 2 because all updates to the cache (addition / removal) are also done via UPDATER, this means that until we have finished loading all updates are buffered preventing out of order updates</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$//1 when passed a raw TokenType - it's likely that the selecting entity does not care about the issuer and so we cannot constrain all selections to using IssuedTokenType</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$//2 when passed an IssuedTokenType - it's likely that the selecting entity does care about the issuer, and so we must filter all tokens which do not match the issuer.</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$//so instead of relying on an indexed view, we can create a predicate on the fly which will constrain the selection to the correct token type</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$//why do we do this? It doesn't really make sense to index on token type, as it's very likely that there will be very few types of tokens in a given vault</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$?:</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$LOG.warn("Attempted to overwrite existing token ${stateAndRef.ref}, this suggests incorrect vault behaviours")</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$private</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$private fun addTokensToCache(stateAndRefs: Collection&lt;StateAndRef&lt;FungibleToken&gt;&gt;)</ID>
    <ID>MaxLineLength:VaultWatcherService.kt$VaultWatcherServiceImpl$throw InsufficientNotLockedBalanceException("Insufficient not-locked spendable states identified for $requiredAmount.")</ID>
    <ID>NestedBlockDepth:DatabaseTokenSelection.kt$DatabaseTokenSelection$@Suspendable override fun selectTokens( holder: Holder, lockId: UUID, requiredAmount: Amount&lt;TokenType&gt;, queryBy: TokenQueryBy ): List&lt;StateAndRef&lt;FungibleToken&gt;&gt;</ID>
    <ID>NestedBlockDepth:VaultWatcherService.kt$VaultWatcherServiceImpl$override fun selectTokens( owner: Holder, requiredAmount: Amount&lt;TokenType&gt;, predicate: ((StateAndRef&lt;FungibleToken&gt;) -&gt; Boolean), allowShortfall: Boolean, autoUnlockDelay: Duration, selectionId: String ): List&lt;StateAndRef&lt;FungibleToken&gt;&gt;</ID>
    <ID>NewLineAtEndOfFile:SelectionUtilities.kt$com.r3.corda.lib.tokens.selection.SelectionUtilities.kt</ID>
    <ID>NewLineAtEndOfFile:Selector.kt$com.r3.corda.lib.tokens.selection.api.Selector.kt</ID>
    <ID>NewLineAtEndOfFile:StateSelectionConfig.kt$com.r3.corda.lib.tokens.selection.api.StateSelectionConfig.kt</ID>
    <ID>NewLineAtEndOfFile:TokenQueryBy.kt$com.r3.corda.lib.tokens.selection.TokenQueryBy.kt</ID>
    <ID>ReturnCount:DatabaseTokenSelection.kt$DatabaseTokenSelection$ @Suspendable private fun executeQuery( requiredAmount: Amount&lt;TokenType&gt;, namedQuery: String, queryParams: Map&lt;String, Any&gt;, stateAndRefs: MutableList&lt;StateAndRef&lt;FungibleToken&gt;&gt;, queryBy: TokenQueryBy ): Amount&lt;TokenType&gt;</ID>
    <ID>SwallowedException:InMemorySelectionConfig.kt$InMemorySelectionConfig$catch (e: IllegalArgumentException) { throw IllegalArgumentException("Couldn't find VaultWatcherService in CordaServices, please make sure that it was installed in node.") }</ID>
    <ID>SwallowedException:InMemorySelectionConfig.kt$InMemorySelectionConfig.Companion$catch (e: ClassCastException) { logger.warn("No indexing method specified. Indexes will be created at run-time for each invocation of selectTokens") emptyList() }</ID>
    <ID>SwallowedException:InMemorySelectionConfig.kt$InMemorySelectionConfig.Companion$catch (e: CordappConfigException) { logger.warn("No indexing method specified. Indexes will be created at run-time for each invocation of selectTokens") emptyList() }</ID>
    <ID>SwallowedException:InMemorySelectionConfig.kt$catch (e: CordappConfigException) { if (exists(path)) { throw IllegalArgumentException("Provide correct database selection configuration for config path: $path") } else { null } }</ID>
    <ID>TooGenericExceptionCaught:VaultWatcherService.kt$VaultWatcherServiceImpl$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:VaultWatcherService.kt$VaultWatcherServiceImpl.&lt;no name provided&gt;$t: Throwable</ID>
    <ID>TooManyFunctions:Selector.kt$Selector</ID>
    <ID>TooManyFunctions:VaultWatcherService.kt$VaultWatcherServiceImpl : VaultWatcherService</ID>
    <ID>VariableNaming:VaultWatcherService.kt$VaultWatcherServiceImpl$private lateinit var __indexed: ConcurrentMap&lt;Class&lt;out Holder&gt;, ConcurrentMap&lt;TokenIndex, TokenBucket&gt;&gt;</ID>
    <ID>VariableNaming:VaultWatcherService.kt$VaultWatcherServiceImpl$private val __backingMap: ConcurrentMap&lt;StateAndRef&lt;FungibleToken&gt;, String&gt; = ConcurrentHashMap()</ID>
    <ID>WildcardImport:DatabaseTokenSelection.kt$import com.r3.corda.lib.tokens.selection.*</ID>
  </CurrentIssues>
</SmellBaseline>
